/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "slProgram.h"
#include "slProcessor.h"

//==============================================================================
slProcessor::slProcessor()
{
    LookAndFeel::setDefaultLookAndFeel (&lookAndFeel);
        
    properties = new PropertiesFile (getSettingsFile(), PropertiesFile::Options());
    
    loadAllPrograms();
    
    state = ValueTree (Identifier ("state"));
}

slProcessor::~slProcessor()
{    
    MessageManagerLock mmLock;
    LookAndFeel::setDefaultLookAndFeel (nullptr);
}

//==============================================================================
void slProcessor::addPluginParameter (slParameter* parameter)
{
    addParameter (parameter);
    
    parameterMap[parameter->getUid()] = parameter;
}

slParameter* slProcessor::getParameter (const String& uid)
{
    if (parameterMap.find (uid) != parameterMap.end())
        return parameterMap[uid];
    
    return nullptr;
}

float slProcessor::parameterValue (const String& uid)
{
    if (parameterMap.find (uid) != parameterMap.end())
        return parameterMap[uid]->getUserValue();
    
    return 0;
    
}

int slProcessor::parameterIntValue (const String& uid)
{
    if (parameterMap.find (uid) != parameterMap.end())
        return int (parameterMap[uid]->getUserValue());
    
    return 0;
}

Array<slParameter*> slProcessor::getPluginParameters()
{
    Array<slParameter*> result;
    
    const OwnedArray<AudioProcessorParameter>& params = getParameters();
    for (AudioProcessorParameter* p : params)
    {
        if (slParameter* pp = dynamic_cast<slParameter*>(p))
            result.add (pp);
    }
    return result;
}

//==============================================================================
const String slProcessor::getName() const
{
    return JucePlugin_Name;
}

bool slProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool slProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

double slProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int slProcessor::getNumPrograms()
{
    return programs.size();
}

int slProcessor::getCurrentProgram()
{
    return currentProgram;
}

void slProcessor::setCurrentProgram (int index)
{
    if (index >= 0 && index < programs.size())
    {
        programs[index]->loadProcessor (this);
        currentProgram = index;
        
        updateHostDisplay();
        sendChangeMessage();
    }
}

const String slProcessor::getProgramName (int index)
{
    return programs[index]->name;
}

void slProcessor::changeProgramName (int index, const String& newName)
{
    programs[index]->deleteFromDir (getProgramDirectory());
    programs[index]->name = newName;
    programs[index]->saveToDir (getProgramDirectory());
    
    updateHostDisplay();
    sendChangeMessage();
}

void slProcessor::loadAllPrograms()
{
    programs.clear();
    
    // create the default program
    slProgram* defaultProgram = new slProgram();
    defaultProgram->name = "Default";
    defaultProgram->saveProcessor (this);
    
    programs.add (defaultProgram);

    // loda programs from disk
    File dir = getProgramDirectory();
    
    Array<File> programFiles;
    dir.findChildFiles (programFiles, File::findFiles, false, "*.xml");
    
    for (File f : programFiles)
    {
        slProgram* program = new slProgram();
        program->loadFromFile (f);
        programs.add (program);
    }
}

void slProcessor::saveProgram (String name)
{
    slProgram* newProgram = new slProgram();
    newProgram->name = name;
    newProgram->saveProcessor (this);
    newProgram->saveToDir (getProgramDirectory());
    
    programs.add (newProgram);
    currentProgram = programs.size() - 1;
    
    updateHostDisplay();
    sendChangeMessage();
}

void slProcessor::deleteProgram (int index)
{
    programs[index]->deleteFromDir (getProgramDirectory());
    programs.remove (index);
    if (index <= currentProgram)
        currentProgram--;
    
    updateHostDisplay();
    sendChangeMessage();
}

File slProcessor::getProgramDirectory()
{
#ifdef JUCE_MAC
    File dir = File::getSpecialLocation(File::userApplicationDataDirectory).getChildFile("Application Support/com.socalabs/" JucePlugin_Name "/programs");
#endif
#ifdef JUCE_WINDOWS
    File dir = File::getSpecialLocation(File::userApplicationDataDirectory).getChildFile("com.socalabs/" JucePlugin_Name "/programs");
#endif
    
    if (!dir.isDirectory())
        dir.createDirectory();
    return dir;
}

File slProcessor::getSettingsFile()
{
#ifdef JUCE_MAC
    File file = File::getSpecialLocation(File::userApplicationDataDirectory).getChildFile("Application Support/com.socalabs/" JucePlugin_Name "/settings.xml");
#endif
#ifdef JUCE_WINDOWS
    File file = File::getSpecialLocation(File::userApplicationDataDirectory).getChildFile("com.socalabs/" JucePlugin_Name "/settings.xml");
#endif
    
    if (!file.getParentDirectory().isDirectory())
        file.getParentDirectory().createDirectory();
    return file;
}
//==============================================================================

void slProcessor::getStateInformation (MemoryBlock& destData)
{
    ScopedPointer<XmlElement> rootE (new XmlElement ("state"));
    
    if (state.isValid())
        rootE->setAttribute ("valueTree", state.toXmlString());
    
    rootE->setAttribute("program", currentProgram);
    
    for (slParameter* p : getPluginParameters())
    {
        if (! p->isMetaParameter())
        {
            slParameter::ParamState pstate = p->getState();
            
            XmlElement* paramE = new XmlElement ("param");
            
            paramE->setAttribute("uid", pstate.uid);
            paramE->setAttribute("val", pstate.value);
            
            rootE->addChildElement (paramE);
        }
    }
    
    MemoryOutputStream os (destData, true);
    rootE->writeToStream (os, String::empty);
}

void slProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    XmlDocument doc (String ((const char*)data, sizeInBytes));
    ScopedPointer<XmlElement> rootE (doc.getDocumentElement());
    if (rootE)
    {
        if (rootE->hasAttribute("valueTree"))
        {
            String xml = rootE->getStringAttribute ("valueTree");
            XmlDocument treeDoc (xml);
            if (ScopedPointer<XmlElement> vtE = treeDoc.getDocumentElement())
                state = ValueTree::fromXml (*vtE.get());
        }
        
        currentProgram = rootE->getIntAttribute ("program");
        
        XmlElement* paramE = rootE->getChildByName ("param");
        while (paramE)
        {
            String uid = paramE->getStringAttribute ("uid");
            float  val = paramE->getStringAttribute ("val").getFloatValue();
            
            if (slParameter* p = getParameter (uid))
            {
                if (! p->isMetaParameter())
                    p->setUserValue (val);
            }
            
            paramE = paramE->getNextElementWithTagName ("param");
        }
    }
}

